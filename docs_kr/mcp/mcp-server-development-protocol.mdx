---
title: "MCP 서버 개발 프로토콜"
description: "이 프로토콜은 Cline으로 MCP 서버를 구축하는 개발 과정을 간소화하도록 설계되었습니다."
---

> **MCP 서버를 만들고 세상과 공유하세요.** 훌륭한 MCP 서버를 만들었다면 [Cline MCP Marketplace](https://github.com/cline/mcp-marketplace)에 제출해 수많은 개발자가 발견하고 원클릭으로 설치할 수 있도록 해주세요.

## MCP 서버란?

Model Context Protocol(MCP) 서버는 Cline 같은 AI 어시스턴트를 확장해 다음을 가능하게 합니다:

-   외부 API 및 서비스 접근
-   실시간 데이터 조회
-   애플리케이션 및 로컬 시스템 제어
-   텍스트 프롬프트만으로는 할 수 없는 작업 수행

MCP가 없으면 AI 어시스턴트는 강력하지만 고립되어 있습니다. MCP를 사용하면 거의 모든 디지털 시스템과 상호작용할 수 있습니다.

## 개발 프로토콜

효과적인 MCP 서버 개발의 핵심은 구조화된 프로토콜을 따르는 것입니다. 이 프로토콜은 MCP 작업 디렉터리 루트(`/Users/your-name/Documents/Cline/MCP`)에 있는 `.clinerules` 파일로 구현됩니다.

### `.clinerules` 파일 사용

`.clinerules` 파일은 Cline이 해당 디렉터리에서 자동으로 읽는 특별한 구성 파일입니다. 이 파일은:

-   Cline의 동작을 구성하고 모범 사례를 강제
-   Cline을 MCP 개발 전용 모드로 전환
-   서버 구축을 위한 단계별 프로토콜 제공
-   조기 완료 방지 같은 안전장치 구현
-   계획, 구현, 테스트 단계를 안내

아래는 `.clinerules` 파일에 넣어야 하는 완전한 MCP 서버 개발 프로토콜입니다:

````markdown
# MCP Server Development Protocol

CRITICAL: DO NOT USE attempt_completion BEFORE TESTING

## Step 1: Planning (PLAN MODE)

-   What problem does this tool solve?
-   What API/service will it use?
-   What are the authentication requirements?
    □ Standard API key
    □ OAuth (requires separate setup script)
    □ Other credentials

## Step 2: Implementation (ACT MODE)

1. Bootstrap

    - For web services, JavaScript integration, or Node.js environments:
        ```bash
        npx @modelcontextprotocol/create-server my-server
        cd my-server
        npm install
        ```
    - For data science, ML workflows, or Python environments:
        ```bash
        pip install mcp
        # Or with uv (recommended)
        uv add "mcp[cli]"
        ```

2. Core Implementation

    - Use MCP SDK
    - Implement comprehensive logging
        - TypeScript (for web/JS projects):
            ```typescript
            console.error("[Setup] Initializing server...")
            console.error("[API] Request to endpoint:", endpoint)
            console.error("[Error] Failed with:", error)
            ```
        - Python (for data science/ML projects):
            ```python
            import logging
            logging.error('[Setup] Initializing server...')
            logging.error(f'[API] Request to endpoint: {endpoint}')
            logging.error(f'[Error] Failed with: {str(error)}')
            ```
    - Add type definitions
    - Handle errors with context
    - Implement rate limiting if needed

3. Configuration

    - Get credentials from user if needed
    - Add to MCP settings:

        - For TypeScript projects:
            ```json
            {
            	"mcpServers": {
            		"my-server": {
            			"command": "node",
            			"args": ["path/to/build/index.js"],
            			"env": {
            				"API_KEY": "key"
            			},
            			"disabled": false,
            			"autoApprove": []
            		}
            	}
            }
            ```
        - For Python projects:

            ```bash
            # Directly with command line
            mcp install server.py -v API_KEY=key

            # Or in settings.json
            {
              "mcpServers": {
                "my-server": {
                  "command": "python",
                  "args": ["server.py"],
                  "env": {
                    "API_KEY": "key"
                  },
                  "disabled": false,
                  "autoApprove": []
                }
              }
            }
            ```

## Step 3: Testing (BLOCKER ⛔️)

<thinking>
BEFORE using attempt_completion, I MUST verify:
□ Have I tested EVERY tool?
□ Have I confirmed success from the user for each test?
□ Have I documented the test results?

If ANY answer is "no", I MUST NOT use attempt_completion.
</thinking>

1. Test Each Tool (REQUIRED)
   □ Test each tool with valid inputs
   □ Verify output format is correct
   DO NOT PROCEED UNTIL ALL TOOLS TESTED

## Step 4: Completion

❗ STOP AND VERIFY:
□ Every tool has been tested with valid inputs
□ Output format is correct for each tool

Only after ALL tools have been tested can attempt_completion be used.

## Key Requirements

-   ✓ Must use MCP SDK
-   ✓ Must have comprehensive logging
-   ✓ Must test each tool individually
-   ✓ Must handle errors gracefully
-   NEVER skip testing before completion
````

이 `.clinerules` 파일이 작업 디렉터리에 있으면 Cline은 다음을 수행합니다:

1. **PLAN MODE**에서 시작해 구현 전 서버를 설계
2. **ACT MODE**에서 올바른 구현 패턴을 강제
3. 모든 도구 테스트가 완료될 때까지 완료를 허용하지 않음
4. 전체 개발 라이프사이클을 안내

## 시작하기

MCP 서버를 만들기 위한 시작 단계는 간단합니다:

### 1. `.clinerules` 파일 생성(중요)

먼저 위 프로토콜을 사용해 MCP 작업 디렉터리 루트에 `.clinerules` 파일을 추가하세요. 이 파일이 Cline을 MCP 개발 프로토콜 모드로 설정합니다.

### 2. 명확한 설명으로 채팅 시작

Cline에게 무엇을 만들고 싶은지 명확히 설명하세요. 다음을 구체적으로 적습니다:

-   MCP 서버의 목적
-   통합하려는 API/서비스
-   필요한 도구나 기능

예시:

```plaintext
AlphaAdvantage 금융 API를 위한 MCP 서버를 만들고 싶어요.
실시간 주식 데이터 조회, 기술적 분석, 기업 재무 정보를 제공해야 해요.
```

### 3. 프로토콜 진행

Cline은 자동으로 PLAN MODE로 시작해 계획 과정을 안내합니다:

-   문제 범위 논의
-   API 문서 검토
-   인증 방법 계획
-   도구 인터페이스 설계

준비가 되면 채팅 하단의 토글로 ACT MODE로 전환해 구현을 시작하세요.

### 4. API 문서를 먼저 제공

MCP 서버를 효율적으로 만들기 위한 가장 좋은 방법 중 하나는 공식 API 문서를 처음에 공유하는 것입니다:

```plaintext
서비스 API 문서입니다:
[여기에 API 문서 붙여넣기]
```

엔드포인트, 인증, 데이터 구조 등 상세 정보를 제공하면 Cline의 구현 품질이 크게 향상됩니다.

## 두 가지 모드 이해하기

### PLAN MODE

이 협업 단계에서 Cline과 함께 MCP 서버를 설계합니다:

-   문제 범위 정의
-   적절한 API 선택
-   인증 방식 계획
-   도구 인터페이스 설계
-   데이터 형식 결정

### ACT MODE

계획이 끝나면 Cline이 구현을 돕습니다:

-   프로젝트 구조 설정
-   구현 코드 작성
-   설정 구성
-   각 컴포넌트 테스트
-   문서 마무리

## 사례 연구: AlphaAdvantage 주식 분석 서버

주식 데이터 분석과 보고를 제공하는 AlphaAdvantage MCP 서버 개발 과정을 살펴봅니다.

### 계획 단계

<Frame>
	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/planning-phase.gif"
		alt="계획 단계 데모"
	/>
</Frame>

계획 단계에서 우리는:

1. **문제를 정의**: 사용자들은 AI 어시스턴트를 통해 금융 데이터, 주식 분석, 시장 인사이트에 접근해야 함
2. **API 선택**: AlphaAdvantage API (금융 시장 데이터)
    - 표준 API 키 인증
    - 분당 5회 호출 제한(무료 티어)
    - 다양한 금융 데이터 타입의 엔드포인트 제공
3. **필요한 도구 설계**:
    - 주식 개요 정보(현재가, 회사 상세)
    - 기술적 분석( RSI, MACD 등)
    - 펀더멘털 분석(재무제표, 비율)
    - 실적 보고 데이터
    - 뉴스 및 감성 분석
4. **데이터 포맷 계획**:
    - 깔끔한 마크다운 출력
    - 구조화 데이터용 테이블
    - 추세 표시(↑/↓)
    - 금융 수치의 올바른 포맷

### 구현

<Frame>
	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/building-mcp-plugin.gif"
		alt="MCP 플러그인 구축 데모"
	/>
</Frame>

프로젝트 부트스트랩:

```bash
npx @modelcontextprotocol/create-server alphaadvantage-mcp
cd alphaadvantage-mcp
npm install axios node-cache
```

프로젝트 구조:

```plaintext
src/
  ├── api/
  │   └── alphaAdvantageClient.ts  # API 클라이언트(레이트 리밋 & 캐시)
  ├── formatters/
  │   └── markdownFormatter.ts     # 깔끔한 마크다운 출력 포맷터
  └── index.ts                     # MCP 서버 메인 구현
```

#### API 클라이언트 구현

API 클라이언트 구현에 포함된 내용:

-   **레이트 리밋**: 분당 5회 제한 강제
-   **캐싱**: 전략적 캐시로 API 호출 줄이기
-   **오류 처리**: 강력한 오류 감지 및 보고
-   **타입 인터페이스**: 모든 데이터에 대한 명확한 TypeScript 타입

핵심 구현:

```typescript
/**
 * Manage rate limiting based on free tier (5 calls per minute)
 */
private async enforceRateLimit() {
  if (this.requestsThisMinute >= 5) {
    console.error("[Rate Limit] Rate limit reached. Waiting for next minute...")
    return new Promise<void>((resolve) => {
      const remainingMs = 60 * 1000 - (Date.now() % (60 * 1000));
      setTimeout(resolve, remainingMs + 100); // Add 100ms buffer
    });
  }

  this.requestsThisMinute++;
  return Promise.resolve();
}
```

#### 마크다운 포맷팅

재무 데이터를 보기 좋게 출력하는 포맷터를 구현했습니다:

```typescript
/**
 * Format company overview into markdown
 */
export function formatStockOverview(overviewData: any, quoteData: any): string {
	// Extract data
	const overview = overviewData
	const quote = quoteData["Global Quote"]

	// Calculate price change
	const currentPrice = parseFloat(quote["05. price"] || "0")
	const priceChange = parseFloat(quote["09. change"] || "0")
	const changePercent = parseFloat(quote["10. change percent"]?.replace("%", "") || "0")

	// Format markdown
	let markdown = `# ${overview.Symbol} (${overview.Name}) - ${formatCurrency(currentPrice)} ${addTrendIndicator(priceChange)}${changePercent > 0 ? "+" : ""}${changePercent.toFixed(2)}%\n\n`

	// Add more details...

	return markdown
}
```

#### 도구 구현

명확한 인터페이스를 가진 5개의 도구를 정의했습니다:

```typescript
server.setRequestHandler(ListToolsRequestSchema, async () => {
	console.error("[Setup] Listing available tools")

	return {
		tools: [
			{
				name: "get_stock_overview",
				description: "Get basic company info and current quote for a stock symbol",
				inputSchema: {
					type: "object",
					properties: {
						symbol: {
							type: "string",
							description: "Stock symbol (e.g., 'AAPL')",
						},
						market: {
							type: "string",
							description: "Optional market (e.g., 'US')",
							default: "US",
						},
					},
					required: ["symbol"],
				},
			},
			// Additional tools defined here...
		],
	}
})
```

각 도구 핸들러에는 다음이 포함됩니다:

-   입력 검증
-   오류 처리 포함 API 호출
-   응답 마크다운 포맷팅
-   포괄적인 로깅

### 테스트 단계

이 핵심 단계에서는 각 도구를 체계적으로 테스트했습니다:

1. 먼저 MCP 서버를 설정에 추가했습니다:

```json
{
	"mcpServers": {
		"alphaadvantage-mcp": {
			"command": "node",
			"args": ["/path/to/alphaadvantage-mcp/build/index.js"],
			"env": {
				"ALPHAVANTAGE_API_KEY": "YOUR_API_KEY"
			},
			"disabled": false,
			"autoApprove": []
		}
	}
}
```

2. 각 도구를 개별적으로 테스트했습니다:

-   **get_stock_overview**: AAPL 주식 개요 정보

    ```markdown
    # AAPL (Apple Inc) - $241.84 ↑+1.91%

    **Sector:** TECHNOLOGY
    **Industry:** ELECTRONIC COMPUTERS
    **Market Cap:** 3.63T
    **P/E Ratio:** 38.26
    ...
    ```

-   **get_technical_analysis**: 가격 변동 및 RSI 데이터

    ```markdown
    # Technical Analysis: AAPL

    ## Daily Price Action

    Current Price: $241.84 (↑$4.54, +1.91%)

    ### Recent Daily Prices

    | Date       | Open    | High    | Low     | Close   | Volume |
    | ---------- | ------- | ------- | ------- | ------- | ------ |
    | 2025-02-28 | $236.95 | $242.09 | $230.20 | $241.84 | 56.83M |

    ...
    ```

-   **get_earnings_report**: MSFT 실적 히스토리 및 보고서

    ```markdown
    # Earnings Report: MSFT (Microsoft Corporation)

    **Sector:** TECHNOLOGY
    **Industry:** SERVICES-PREPACKAGED SOFTWARE
    **Current EPS:** $12.43

    ## Recent Quarterly Earnings

    | Quarter    | Date       | EPS Estimate | EPS Actual | Surprise % |
    | ---------- | ---------- | ------------ | ---------- | ---------- |
    | 2024-12-31 | 2025-01-29 | $3.11        | $3.23      | ↑4.01%     |

    ...
    ```

### 도전과 해결

개발 중 다음과 같은 문제를 겪었습니다:

1. **API 레이트 리밋**:
    - **문제**: 무료 티어는 분당 5회 제한
    - **해결**: 큐잉, 레이트 리밋 강제, 캐싱 적용
2. **데이터 포맷**:
    - **문제**: 원본 API 데이터가 사용하기 어려움
    - **해결**: 일관된 출력 포맷 유틸리티 작성
3. **타임아웃 문제**:
    - **문제**: 복잡한 도구가 여러 API 호출을 수행하면 타임아웃 가능
    - **해결**: 도구를 더 작은 단위로 분리하고 캐싱 최적화 권장

### 배운 점

AlphaAdvantage 구현을 통해 다음을 배웠습니다:

1. **API 제한 고려**: 시작부터 레이트 리밋을 고려해 설계
2. **전략적 캐싱**: 고가치 캐싱 포인트 식별
3. **가독성 높은 포맷**: 사용자 경험을 위한 데이터 포맷 투자
4. **모든 경로 테스트**: 완료 전 모든 도구 개별 테스트
5. **API 복잡성 처리**: 다중 호출 API는 범위를 단순화한 도구로 설계

## 핵심 구현 모범 사례

### 포괄적인 로깅

효과적인 로깅은 MCP 서버 디버깅에 필수입니다:

```typescript
// Start-up logging
console.error("[Setup] Initializing AlphaAdvantage MCP server...")

// API request logging
console.error(`[API] Getting stock overview for ${symbol}`)

// Error handling with context
console.error(`[Error] Tool execution failed: ${error.message}`)

// Cache operations
console.error(`[Cache] Using cached data for: ${cacheKey}`)
```

### 강한 타입 지정

타입 정의는 오류를 줄이고 유지보수성을 높입니다:

```typescript
export interface AlphaAdvantageConfig {
	apiKey: string
	cacheTTL?: Partial<typeof DEFAULT_CACHE_TTL>
	baseURL?: string
}

/**
 * Validate that a stock symbol is provided and looks valid
 */
function validateSymbol(symbol: unknown): asserts symbol is string {
	if (typeof symbol !== "string" || symbol.trim() === "") {
		throw new McpError(ErrorCode.InvalidParams, "A valid stock symbol is required")
	}

	// Basic symbol validation (letters, numbers, dots)
	const symbolRegex = /^[A-Za-z0-9.]+$/
	if (!symbolRegex.test(symbol)) {
		throw new McpError(ErrorCode.InvalidParams, `Invalid stock symbol: ${symbol}`)
	}
}
```

### 지능형 캐싱

API 호출을 줄이고 성능을 향상시킵니다:

```typescript
// Default cache TTL in seconds
const DEFAULT_CACHE_TTL = {
	STOCK_OVERVIEW: 60 * 60, // 1 hour
	TECHNICAL_ANALYSIS: 60 * 30, // 30 minutes
	FUNDAMENTAL_ANALYSIS: 60 * 60 * 24, // 24 hours
	EARNINGS_REPORT: 60 * 60 * 24, // 24 hours
	NEWS: 60 * 15, // 15 minutes
}

// Check cache first
const cachedData = this.cache.get<T>(cacheKey)
if (cachedData) {
	console.error(`[Cache] Using cached data for: ${cacheKey}`)
	return cachedData
}

// Cache successful responses
this.cache.set(cacheKey, response.data, cacheTTL)
```

### 우아한 오류 처리

좋은 사용자 경험을 유지하는 강력한 오류 처리를 구현하세요:

```typescript
try {
	switch (request.params.name) {
		case "get_stock_overview": {
			// Implementation...
		}

		// Other cases...

		default:
			throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`)
	}
} catch (error) {
	console.error(`[Error] Tool execution failed: ${error instanceof Error ? error.message : String(error)}`)

	if (error instanceof McpError) {
		throw error
	}

	return {
		content: [
			{
				type: "text",
				text: `Error: ${error instanceof Error ? error.message : String(error)}`,
			},
		],
		isError: true,
	}
}
```

## MCP 리소스

리소스는 코드를 실행하지 않고도 MCP 서버가 Cline에 데이터를 노출하도록 해줍니다. 파일, API 응답, DB 기록 같은 컨텍스트를 제공할 때 유용합니다.

### MCP 서버에 리소스 추가

1. **노출할 리소스 정의**:

```typescript
server.setRequestHandler(ListResourcesRequestSchema, async () => {
	return {
		resources: [
			{
				uri: "file:///project/readme.md",
				name: "Project README",
				mimeType: "text/markdown",
			},
		],
	}
})
```

2. **읽기 핸들러 구현**:

```typescript
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
	if (request.params.uri === "file:///project/readme.md") {
		const content = await fs.promises.readFile("/path/to/readme.md", "utf-8")
		return {
			contents: [
				{
					uri: request.params.uri,
					mimeType: "text/markdown",
					text: content,
				},
			],
		}
	}

	throw new Error("Resource not found")
})
```

리소스는 Cline이 필요한 정보를 복사/붙여넣기 없이 참조하게 해, 서버를 더 컨텍스트 친화적으로 만듭니다. 자세한 내용은 [공식 문서](https://modelcontextprotocol.io/docs/concepts/resources)를 참고하세요.

## 일반적인 문제와 해결

### API 인증 복잡성

**문제**: API마다 인증 방식이 다름.

**해결**:

-   API 키는 MCP 구성의 환경 변수로 설정
-   OAuth는 별도 스크립트로 리프레시 토큰 획득
-   민감한 토큰을 안전하게 저장

```typescript
// Authenticate using API key from environment
const API_KEY = process.env.ALPHAVANTAGE_API_KEY
if (!API_KEY) {
	console.error("[Error] Missing ALPHAVANTAGE_API_KEY environment variable")
	process.exit(1)
}

// Initialize API client
const apiClient = new AlphaAdvantageClient({
	apiKey: API_KEY,
})
```

### 부족하거나 제한된 API 기능

**문제**: API가 필요한 기능을 제공하지 않을 수 있음.

**해결**:

-   가능한 엔드포인트로 대체 기능 구현
-   필요 시 시뮬레이션 기능 생성
-   API 데이터를 변환해 요구에 맞게 사용

### API 레이트 리밋

**문제**: 대부분의 API는 레이트 리밋으로 실패가 발생할 수 있음.

**해결**:

-   적절한 레이트 리밋 구현
-   지능형 캐싱 추가
-   우아한 degradation 제공
-   레이트 리밋 오류를 투명하게 표시

```typescript
if (this.requestsThisMinute >= 5) {
	console.error("[Rate Limit] Rate limit reached. Waiting for next minute...")
	return new Promise<void>((resolve) => {
		const remainingMs = 60 * 1000 - (Date.now() % (60 * 1000))
		setTimeout(resolve, remainingMs + 100) // Add 100ms buffer
	})
}
```

## 추가 리소스

-   [MCP Protocol Documentation](https://github.com/modelcontextprotocol/mcp)
-   [MCP SDK Documentation](https://github.com/modelcontextprotocol/sdk-js)
-   [MCP Server Examples](https://github.com/modelcontextprotocol/servers)
